<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Video with Depth and GPGPU Curl Noise</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }
        #webgl-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #video {
            display: none;
        }
    </style>
    <style type="text/css">
        .dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
    </style>
</head>
<body>
    <div id="info">
        WebXR Video with Depth and GPGPU Curl Noise - Use WebXR device to view
    </div>
    <video id="video" loop crossorigin="anonymous" muted playsinline src="beach.mp4"></video>
    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { XRButton } from 'three/addons/webxr/XRButton.js';
        import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';

        let scene, camera, renderer, controls, video, videoTexture, particles, particleMaterial, gpgpuParticles, gpgpuParticleMaterial, gpuCompute, positionVariable;
        const GRID_WIDTH = 512;
        const GRID_HEIGHT = 256;
        const VISUAL_RESOLUTION_X = 1024;
        const VISUAL_RESOLUTION_Y = 512;

        const params = {
            particleSize: 2000.0,
            focalLengthX: 1100.0,
            focalLengthY: 1100.0,
            minZ: -1000.0,
            maxZ: -120.0,
            reverseDepthMap: false,
            farOffAmount: 0.0,
            showGpgpuParticles: true,
            gpgpuLifeDuration: 5.0,
            gpgpuSpeed: 40.0,
            gpgpuOpacity: 0.25,
            curlAmplitude: 40.0,
            curlFrequency: 0.005,
            additiveBlending: true
        };

        function init() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.z = 210;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 1);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            document.body.appendChild(XRButton.createButton(renderer, { requiredFeatures: ['hand-tracking'] }));

            // Video setup
            video = document.getElementById('video');
            video.play().catch(e => console.error('Video auto-play failed:', e));
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.NearestFilter;
            videoTexture.magFilter = THREE.NearestFilter;
            videoTexture.format = THREE.RGBAFormat;

            // Main hologram particle geometry
            const geometry = createParticleGeometry(GRID_WIDTH, GRID_HEIGHT);

            // Main hologram particle material
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_videoTexture: { value: videoTexture },
                    u_size: { value: params.particleSize },
                    u_focalLengthX: { value: params.focalLengthX },
                    u_focalLengthY: { value: params.focalLengthY },
                    u_minZ: { value: params.minZ },
                    u_maxZ: { value: params.maxZ },
                    u_resolution: { value: new THREE.Vector2(VISUAL_RESOLUTION_X, VISUAL_RESOLUTION_Y) },
                    u_depthMapResolution: { value: new THREE.Vector2(VISUAL_RESOLUTION_X, VISUAL_RESOLUTION_Y / 2) },
                    u_reverseDepth: { value: params.reverseDepthMap ? 1.0 : 0.0 },
                    u_farOffAmount: { value: params.farOffAmount }
                },
                vertexShader: `
                    uniform sampler2D u_videoTexture;
                    uniform float u_size;
                    uniform float u_focalLengthX;
                    uniform float u_focalLengthY;
                    uniform float u_minZ;
                    uniform float u_maxZ;
                    uniform vec2 u_resolution;
                    uniform vec2 u_depthMapResolution;
                    uniform float u_reverseDepth;

                    varying vec2 vOriginalUv;
                    varying float vDepth;

                    void main() {
                        vec2 gridUv = position.xy;
                        vOriginalUv = gridUv;
                        vec2 depthTextureUv = vec2(gridUv.x, gridUv.y * 0.5);
                        vec2 depthTexelSize = 1. / u_depthMapResolution;
                        vec2 pixelCoord = depthTextureUv * u_depthMapResolution;
                        vec2 fractCoord = fract(pixelCoord);
                        vec2 basePixel = floor(pixelCoord);
                        vec2 uv00 = (basePixel + vec2(0.5, 0.5)) * depthTexelSize;
                        vec2 uv10 = (basePixel + vec2(1.5, 0.5)) * depthTexelSize;
                        vec2 uv01 = (basePixel + vec2(0.5, 1.5)) * depthTexelSize;
                        vec2 uv11 = (basePixel + vec2(1.5, 1.5)) * depthTexelSize;
                        float d00 = texture2D(u_videoTexture, uv00).r;
                        float d10 = texture2D(u_videoTexture, uv10).r;
                        float d01 = texture2D(u_videoTexture, uv01).r;
                        float d11 = texture2D(u_videoTexture, uv11).r;
                        float interp0 = mix(d00, d10, fractCoord.x);
                        float interp1 = mix(d01, d11, fractCoord.y);
                        float depth = mix(interp0, interp1, fractCoord.y);
                        depth = clamp(depth, 0.0, 1.0);
                        vDepth = depth;
                        if (u_reverseDepth > 0.5) {
                            depth = 1.0 - depth;
                        }
                        float x_pixel = (1.0 - gridUv.x) * u_resolution.x - u_resolution.x / 2.0;
                        float y_pixel = (1.0 - gridUv.y) * u_resolution.y - u_resolution.y / 2.0;
                        float z_world = mix(u_minZ, u_maxZ, depth);
                        vec3 particlePosition;
                        particlePosition.x = (x_pixel * z_world) / u_focalLengthX;
                        particlePosition.y = (y_pixel * z_world) / u_focalLengthY;
                        particlePosition.z = z_world;
                        vec4 modelViewPosition = modelViewMatrix * vec4(particlePosition, 1.0);
                        gl_Position = projectionMatrix * modelViewPosition;
                        float objectScale = length(vec3(modelViewMatrix[0]));
                        gl_PointSize = u_size * objectScale * (1.0 / -modelViewPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D u_videoTexture;
                    varying vec2 vOriginalUv;
                    varying float vDepth;
                    uniform float u_farOffAmount;

                    void main() {
                        if (vOriginalUv.y > 0.994) discard;
                        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {
                            discard;
                        }
                        vec2 colorUv = vec2(vOriginalUv.x, vOriginalUv.y * 0.5 + 0.5);
                        vec4 color = texture2D(u_videoTexture, colorUv);
                        if (color.a < 0.1) discard;
                        float farFadeOpacity = u_farOffAmount > 0.001 ? smoothstep(0.0, u_farOffAmount, vDepth) : 1.0;
                        color.a *= farFadeOpacity * 0.65;
                        if (color.a < 0.1) discard;
                        gl_FragColor = color;
                    }
                `,
                transparent: true
            });

            particles = new THREE.Points(geometry, particleMaterial);
            particles.frustumCulled = false;
            scene.add(particles);

            // Initialize GPGPU particles
            initGpgpuParticles();

            // GUI setup
            const gui = new dat.GUI();
            gui.add(params, 'particleSize', 2, 4000.0).onChange(value => {
                particleMaterial.uniforms.u_size.value = value;
                gpgpuParticleMaterial.uniforms.u_size.value = value;
            });
            gui.add(params, 'focalLengthX', 1.0, 2000.0).onChange(value => {
                particleMaterial.uniforms.u_focalLengthX.value = value;
                positionVariable.material.uniforms.u_focalLengthX.value = value;
            });
            gui.add(params, 'focalLengthY', 1.0, 2000.0).onChange(value => {
                particleMaterial.uniforms.u_focalLengthY.value = value;
                positionVariable.material.uniforms.u_focalLengthY.value = value;
            });
            gui.add(params, 'minZ', -1000.0, 0.0).onChange(value => {
                particleMaterial.uniforms.u_minZ.value = value;
                positionVariable.material.uniforms.u_minZ.value = value;
            });
            gui.add(params, 'maxZ', -2000.0, -10.0).onChange(value => {
                particleMaterial.uniforms.u_maxZ.value = value;
                positionVariable.material.uniforms.u_maxZ.value = value;
            });
            gui.add(params, 'reverseDepthMap').name('Reverse Depth Map').onChange(value => {
                const val = value ? 1.0 : 0.0;
                particleMaterial.uniforms.u_reverseDepth.value = val;
                positionVariable.material.uniforms.u_reverseDepth.value = val;
            });
            gui.add(params, 'farOffAmount', 0, 1.0).name('Far Off Filter').onChange(value => {
                particleMaterial.uniforms.u_farOffAmount.value = value;
                gpgpuParticleMaterial.uniforms.u_farOffAmount.value = value;
            });

            const fxFolder = gui.addFolder('FX Particle Controls');
            fxFolder.add(params, 'showGpgpuParticles').name('Show FX Particles').onChange(value => {
                gpgpuParticles.visible = value;
            });
            fxFolder.add(params, 'gpgpuLifeDuration', 1.0, 10.0).name('Life Duration').onChange(value => {
                positionVariable.material.uniforms.u_lifeDuration.value = value;
            });
            fxFolder.add(params, 'gpgpuSpeed', -300.0, 300.0).name('Forward Speed').onChange(value => {
                positionVariable.material.uniforms.u_zSpeed.value = value;
            });
            fxFolder.add(params, 'gpgpuOpacity', 0.01, 0.5).name('Overall Opacity').onChange(value => {
                gpgpuParticleMaterial.uniforms.u_opacity.value = value;
            });
            fxFolder.add(params, 'curlAmplitude', 0.0, 200.0).name('Curl Amplitude').onChange(value => {
                positionVariable.material.uniforms.u_curlAmplitude.value = value;
            });
            fxFolder.add(params, 'curlFrequency', 0.001, 0.05).name('Curl Frequency').onChange(value => {
                positionVariable.material.uniforms.u_curlFrequency.value = value;
            });
            fxFolder.add(params, 'additiveBlending').name('Additive Blending').onChange(value => {
                gpgpuParticleMaterial.blending = value ? THREE.AdditiveBlending : THREE.NormalBlending;
                gpgpuParticleMaterial.needsUpdate = true;
            });
            fxFolder.open();

            // Adjust for WebXR
            renderer.xr.addEventListener('sessionstart', () => {
                particleMaterial.uniforms.u_size.value = 2400.0;
                gpgpuParticleMaterial.uniforms.u_size.value = 2400.0;
                particles.scale.set(0.009, 0.009, 0.009);
                particles.position.set(0, 1.4, 0.5);
                gpgpuParticles.scale.set(0.009, 0.009, 0.009);
                gpgpuParticles.position.set(0, 1.4, 0.5);
            });
            renderer.xr.addEventListener('sessionend', () => {
                particleMaterial.uniforms.u_size.value = 2000.0;
                gpgpuParticleMaterial.uniforms.u_size.value = 2000.0;
                particles.scale.set(1, 1, 1);
                particles.position.set(0, 0, 0);
                gpgpuParticles.scale.set(1, 1, 1);
                gpgpuParticles.position.set(0, 0, 0);
            });

            // Orbit controls for desktop
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(animate);
        }

        function createParticleGeometry(width, height) {
            const NUM_PARTICLES = width * height;
            const geometry = new THREE.BufferGeometry();
            const gridUvs = new Float32Array(NUM_PARTICLES * 3);
            const randoms = new Float32Array(NUM_PARTICLES);
            let pIdx = 0;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    gridUvs[pIdx * 3 + 0] = x / (width - 1);
                    gridUvs[pIdx * 3 + 1] = y / (height - 1);
                    gridUvs[pIdx * 3 + 2] = 0;
                    randoms[pIdx] = Math.random();
                    pIdx++;
                }
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(gridUvs, 3));
            geometry.setAttribute('a_random', new THREE.BufferAttribute(randoms, 1));
            return geometry;
        }

        function initGpgpuParticles() {
            gpuCompute = new GPUComputationRenderer(GRID_WIDTH, GRID_HEIGHT, renderer);
            if (renderer.capabilities.isWebGL2 === false) {
                gpuCompute.setDataType(THREE.HalfFloatType);
            }

            const dtPosition = gpuCompute.createTexture();
            const p = dtPosition.image.data;
            for (let i = 0; i < p.length; i += 4) {
                p[i + 0] = 0;
                p[i + 1] = 0;
                p[i + 2] = 0;
                p[i + 3] = -1.0;
            }

            positionVariable = gpuCompute.addVariable('texturePosition', gpgpuPositionShader(), dtPosition);
            gpuCompute.setVariableDependencies(positionVariable, [positionVariable]);

            positionVariable.material.uniforms['u_time'] = { value: 0.0 };
            positionVariable.material.uniforms['u_deltaTime'] = { value: 0.0 };
            positionVariable.material.uniforms['u_videoTexture'] = { value: videoTexture };
            positionVariable.material.uniforms['u_focalLengthX'] = { value: params.focalLengthX };
            positionVariable.material.uniforms['u_focalLengthY'] = { value: params.focalLengthY };
            positionVariable.material.uniforms['u_minZ'] = { value: params.minZ };
            positionVariable.material.uniforms['u_maxZ'] = { value: params.maxZ };
            positionVariable.material.uniforms['u_resolution'] = { value: new THREE.Vector2(VISUAL_RESOLUTION_X, VISUAL_RESOLUTION_Y) };
            positionVariable.material.uniforms['u_depthMapResolution'] = { value: new THREE.Vector2(VISUAL_RESOLUTION_X, VISUAL_RESOLUTION_Y / 2) };
            positionVariable.material.uniforms['u_reverseDepth'] = { value: params.reverseDepthMap ? 1.0 : 0.0 };
            positionVariable.material.uniforms['u_lifeDuration'] = { value: params.gpgpuLifeDuration };
            positionVariable.material.uniforms['u_zSpeed'] = { value: params.gpgpuSpeed };
            positionVariable.material.uniforms['u_curlAmplitude'] = { value: params.curlAmplitude };
            positionVariable.material.uniforms['u_curlFrequency'] = { value: params.curlFrequency };
            positionVariable.material.uniforms['u_emitterMatrix'] = { value: new THREE.Matrix4() };
            positionVariable.material.uniforms['u_emitterScale'] = { value: 1.0 };
            positionVariable.material.uniforms['u_forward'] = { value: new THREE.Vector3(0, 0, 1) };

            const error = gpuCompute.init();
            if (error !== null) {
                console.error(error);
            }

            gpgpuParticleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_positions: { value: null },
                    u_videoTexture: { value: videoTexture },
                    u_size: { value: params.particleSize },
                    u_opacity: { value: params.gpgpuOpacity },
                    u_farOffAmount: { value: params.farOffAmount }
                },
                vertexShader: `
                    uniform sampler2D u_positions;
                    uniform sampler2D u_videoTexture;
                    uniform float u_size;

                    attribute float a_random;
                    varying vec2 vOriginalUv;
                    varying float vLife;
                    varying float vDepth;

                    void main() {
                        vec2 gridUv = position.xy;
                        vOriginalUv = gridUv;

                        vec4 posLife = texture2D(u_positions, gridUv);
                        vec3 worldPosition = posLife.xyz;
                        vLife = posLife.w;

                        vec2 depthTextureUv = vec2(gridUv.x, gridUv.y * 0.5);
                        vDepth = texture2D(u_videoTexture, depthTextureUv).r;

                        vec4 viewPosition = viewMatrix * vec4(worldPosition, 1.0);
                        gl_Position = projectionMatrix * viewPosition;

                        float objectScale = length(vec3(modelMatrix[0]));
                        gl_PointSize = u_size * objectScale * (1.0 / -viewPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D u_videoTexture;
                    uniform float u_opacity;
                    uniform float u_farOffAmount;

                    varying vec2 vOriginalUv;
                    varying float vLife;
                    varying float vDepth;

                    void main() {
                        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {
                            discard;
                        }

                        vec2 colorUv = vec2(vOriginalUv.x, vOriginalUv.y * 0.5 + 0.5);
                        vec4 color = texture2D(u_videoTexture, colorUv);

                        if (color.a < 0.1) discard;

                        float lifeFade = smoothstep(0.0, 1.5, vLife);
                        float depthFade = u_farOffAmount > 0.001 ? smoothstep(0.0, u_farOffAmount, vDepth) : 1.0;
                        color.a *= lifeFade * depthFade * u_opacity;

                        gl_FragColor = color;
                    }
                `,
                transparent: true,
                blending: params.additiveBlending ? THREE.AdditiveBlending : THREE.NormalBlending,
                depthWrite: false
            });

            gpgpuParticles = new THREE.Points(particles.geometry, gpgpuParticleMaterial);
            gpgpuParticles.frustumCulled = false;
            gpgpuParticles.visible = params.showGpgpuParticles;
            scene.add(gpgpuParticles);
        }

        function gpgpuPositionShader() {
            return `
                uniform float u_time;
                uniform float u_deltaTime;
                uniform float u_lifeDuration;
                uniform float u_zSpeed;
                uniform float u_curlAmplitude;
                uniform float u_curlFrequency;
                uniform mat4 u_emitterMatrix;
                uniform float u_emitterScale;
                uniform vec3 u_forward;
                uniform sampler2D u_videoTexture;
                uniform float u_focalLengthX;
                uniform float u_focalLengthY;
                uniform float u_minZ;
                uniform float u_maxZ;
                uniform vec2 u_resolution;
                uniform vec2 u_depthMapResolution;
                uniform float u_reverseDepth;

                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);
                    vec4 x = x_ * ns.x + ns.yyyy;
                    vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                }

                vec3 curlNoise(vec3 p) {
                    const float e = 0.1;
                    float n1, n2, n3, n4;
                    n1 = snoise(vec3(p.x, p.y + e, p.z)); n2 = snoise(vec3(p.x, p.y - e, p.z));
                    n3 = snoise(vec3(p.x, p.y, p.z + e)); n4 = snoise(vec3(p.x, p.y, p.z - e));
                    float cx = (n1 - n2) - (n3 - n4);
                    n1 = snoise(vec3(p.x, p.y, p.z + e)); n2 = snoise(vec3(p.x, p.y, p.z - e));
                    n3 = snoise(vec3(p.x + e, p.y, p.z)); n4 = snoise(vec3(p.x - e, p.y, p.z));
                    float cy = (n1 - n2) - (n3 - n4);
                    n1 = snoise(vec3(p.x + e, p.y, p.z)); n2 = snoise(vec3(p.x - e, p.y, p.z));
                    n3 = snoise(vec3(p.x, p.y + e, p.z)); n4 = snoise(vec3(p.x, p.y - e, p.z));
                    float cz = (n1 - n2) - (n3 - n4);
                    return vec3(cx, cy, cz);
                }

                float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 posLife = texture2D(texturePosition, uv);
                    vec3 pos = posLife.xyz;
                    float life = posLife.w;

                    life -= u_deltaTime;

                    if (life < 0.0) {
                        vec2 gridUv = uv;
                        vec2 depthTextureUv = vec2(gridUv.x, gridUv.y * 0.5);
                        float depth = texture2D(u_videoTexture, depthTextureUv).r;
                        if (u_reverseDepth > 0.5) { depth = 1.0 - depth; }
                        float x_pixel = (1.0 - gridUv.x) * u_resolution.x - u_resolution.x / 2.0;
                        float y_pixel = (1.0 - gridUv.y) * u_resolution.y - u_resolution.y / 2.0;
                        float z_world = mix(u_minZ, u_maxZ, depth);
                        vec3 localPos;
                        localPos.x = (x_pixel * z_world) / u_focalLengthX;
                        localPos.y = (y_pixel * z_world) / u_focalLengthY;
                        localPos.z = z_world;
                        pos = (u_emitterMatrix * vec4(localPos, 1.0)).xyz;
                        life = u_lifeDuration + u_lifeDuration * (rand(uv + u_time) * 2.0 - 1.0) * 0.5;
                    } else {
                        pos += u_forward * u_zSpeed * u_emitterScale * u_deltaTime;
                        vec3 noise_coord = pos / u_emitterScale;
                        vec3 turbulence = curlNoise(noise_coord * u_curlFrequency);
                        pos += turbulence * u_curlAmplitude * u_emitterScale * u_deltaTime;
                    }

                    gl_FragColor = vec4(pos, life);
                }
            `;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const clock = new THREE.Clock();
        let lastTime = 0;
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        const worldScale = new THREE.Vector3();
        const forwardVector = new THREE.Vector3();

        function animate() {
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = elapsedTime - lastTime;
            lastTime = elapsedTime;

            controls.update();

            if (gpuCompute) {
                gpgpuParticles.updateMatrixWorld();
                const matrix = gpgpuParticles.matrixWorld;
                matrix.decompose(worldPos, worldQuat, worldScale);
                forwardVector.set(0, 0, 1).applyQuaternion(worldQuat);

                positionVariable.material.uniforms.u_emitterMatrix.value.copy(matrix);
                positionVariable.material.uniforms.u_emitterScale.value = worldScale.x;
                positionVariable.material.uniforms.u_forward.value.copy(forwardVector);
                positionVariable.material.uniforms.u_time.value = elapsedTime;
                positionVariable.material.uniforms.u_deltaTime.value = deltaTime;

                gpuCompute.compute();

                gpgpuParticleMaterial.uniforms.u_positions.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>